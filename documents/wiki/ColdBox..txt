= What is ColdBox? =

[[PageOutline]]

!ColdBox is a proven event-driven CFC based !ColdFusion Framework, specifically designed for high availability web applications. The purpose behind !ColdBox was to create a fast & stable development methodology that could be shared among several developers. It makes use of an MVC (Model View Controller) design pattern implemented via CFC's. It uses event handler CFC's that hold all the code necessary to prepare views, call model CFC's, use !ColdBox [wiki:ColdBox#Plugins plugins], and redirect requests through the !ColdBox Controller.   You can consider the event handlers to be all that code that you had on top of your templates, but now moved to an Object Oriented pattern.  In this article you will have an overview of the main components of this Object Oriented Framework.

{{{
#!html
<div align="center"><img src="http://www.luismajano.com/fileshare/blog/ColdboxMVCDesignPattern.jpg" style="border: 1px outset #eaeaea" /></div>
}}}

== Features & Capabilities ==

Please see [wiki:cbFeatures]

== How it Works? ==

!ColdBox uses both implicit and explicit invocation methods to execute events and render content.  You have one single xml file: config.xml, from where you can configure your entire application and plugins.  You can use [http://www.coldspringframework.org/ ColdSpring], [http://www.doughughes.net/index.cfm?event=viewEntry&entryId=189 Reactor], Remoting, CRUD, Bean/DAO Factories or any other technology and/or pattern that you can think off with !ColdBox. However, !ColdBox does make you adhere to an application [wiki:cbDirectoryStructure directory structure] and some [wiki:cbNamingConventions naming conventions].  This is done with the purpose of creating a standard for all developers in the same team to share and for !ColdBox to find what it needs. 

{{{
#!html
<blockquote>You are only limited by your ingenuity</blockquote>
}}}

== Implicit & Explicit Invocations ==

!ColdBox Events can be registered for execution in two different ways. Events can be registered for the following via the config.xml, which are ran implicitly:

  * onRequestStart
  * onRequestEnd
  * onApplicationStart
  * defaultEvent
  * onException

The other method to register events are via explicit declarations in your event handlers, which are CFC's.  From these events, you declare what model actions to invoke, what layout/view to render, call plugins, and if more events need to be executed. All these actions are done explicitly, you define them in CF code and not in XML Dialect.  ColdBox then implicitly renders layouts/views set by the event handlers and finalizes execution.

One thing to note, is that the event handler's events (''methods'') are very loosely coupled from each other. They interact on their own and do what they need to do and surrender execution to the framework. I believe that you will get a better understanding of Implicit Invocation by reading this '''great''' document by Ben Edwards from the Mach-II project. 

http://www.mach-ii.com/downloads/docs/Intro%20to%20Implicit%20Invocation.pdf

As you can see, due to the nature of event handler's defined in !ColdFusion, you have explicit declarations that would otherwise be implicit if done in an XML based dialect. Thus, the cohesion between implicit and explicit. At the end of the day, ColdBox is based on events and cannot function without them.

Below is a quote by Oscar Arevalo concerning ColdBox's functionality:

{{{
#!html
<blockquote>"ColdBox takes a more direct approach to determine what gets called and when; yes, this adds some coupling between the views and the event handlers, but the benefit is that the amount of indirection and obfuscation is reduced; resulting in what I think is one of the biggest benefits of coldbox: that you actually program in coldfusion, and not in some XML dialect. This results in applications that are very easy to follow, even if the framework is not there."
by Oscar Arevalo
</blockquote >
}}}

== Config.xml  ==

!ColdBox is configured for operation via a single xml file.  You can define the major settings for your application, what features to use, etc.  You need to read the following guides and tutorials to understand much better the possibilities with !ColdBox

  * [wiki:cbConfigGuide Config Guide]
  * [http://www.luismajano.com/blog/index.cfm/2006/7/18/ColdBox-Configxml-Tutorial-Part-I Config.xml Tutorial Part I]
  * [http://www.luismajano.com/blog/index.cfm/2006/7/19/ColdBox-Framework-Configxml-Tutorial-Part-II Config.xml Tutorial Part II]

== Event Handlers (cfc's) ==

!ColdBox Event handlers are cfc's that follow certain guidelines. Most of this topic is covered in the [wiki:cbEventHandlersGuide Event Handlers Guide].  

  * First of all, these cfc's must extend the coldbox eventhandler base cfc: '''coldbox.system.eventhandler'''
  * They must have an init method with the following standard:

{{{
<cffunction name="init" access="public" returntype="any" output="false">
  <cfset super.init()>
  <cfreturn this>
</cffunction>
}}}
  
  * The must exist in the correct '''handlers''' directory under your application. See [wiki:cbDirectoryStructure]
  * Then you need to create methods that will respond to events. !ColdBox uses the '''event''' action variable on form submits and url parameters to determine what event to execute.  

The format of this event variable is '''{event_handler cfc}.{method}'''

This looks very similar to a java/cfc method call, example: ''String.getLength()'', but without the parenthesis. Once the event variable is set, the framework runs a regular expression match on the event string in order to validate it. If the match is successful, the framework will then tokenize the event string to retrieve the cfc and method call and validate it against the internal registered events. It then continues to instantiate the event handler cfc and execute the event handler's method.
  * Public methods in the event handler that will be executed by the framework need to be of three types
    * '''on{name}''' : Usually for facades to onRequestStart, onApplicationStart,etc or for custom events like: onException, onOverride, etc. 
    * '''dsp{name}''' : These methods are usually used to prepare a view for display.  Let's say that your are preparing a view that needs two queries in order to be displayed.  You will place those query model calls here and then set the view to be rendered.  Example: dspLogin, dspUserListings. 
    * '''do{name}''' : These methods are most likely your model invocation calls, depending on your application.  The main purpose is for them to carry out a certain processing operation.  Example: doLogin, doCreateAccount.  You can then decide to set a view to render or relocate to another event by using the '''setNextEvent(event)''' method.

See [wiki:cbDirectoryStructure] [wiki:cbNamingConventions] [wiki:cbEventHandlersGuide]

== Request Collection ==

!ColdBox also uses a request collection data structure where all variables can be stored and shared among an execution request. The Request Collection is a central repository of information that is refreshed on every user request.  This is how data gets moved around from event handlers to views and layouts to plugins and anything running inside of the framework. You do not have to scope it within your application, but just use the provided methods: '''setValue(), getValue(), removeValue(), getCollection(), valueExists()''' to interact with the request collection.

== Plugins ==

Another important !ColdBox feature is the use of a plugin library of CFC's that extend the normal usage of !ColdBox to application specific tasks but without hindering system performance.  These plugins are reusable components that your applications can use and can be loaded on demand via a Plugin Factory. Thus, your plugins are not utilized or loaded into a scope, they are just invoked. Some samples are: i18n, resource bundles, refresh a webservice stub, Bug Reports, java file utilities, etc.  This is a major difference between !ColdBox and any other framework, in that it gives you a set of reusable on-demand components for tedious or repeatable application-specific tasks.

Also, not only can you use and modify the plugins that come with every !ColdBox installation, '''but you can create your own'''.  You are not limited anymore, you can extend the framework to your needs. You can create as many plugins as you want and build a plugins library that can be located by just specifying it on the config.xml.   You will then be able to get the plugin and use it on any of your !ColdBox applications.  The best part of it all, is that the plugin will inherit all of the framework's functionality, so you have everything that you need to be able to code.

How easy is it? well, you just do the following:

  * Make your plugin cfc extend '''coldbox.system.plugin'''
  * Create an init method with the following code:

{{{
<cffunction name="init" access="public" returntype="any" output="false">
  <cfargument name="controller" required="yes" hint="The reference to the framework controller">
  <cfset super.Init(arguments.controller) />
  <!--- Any initialization custom code place below --->
  <cfreturn this>
</cffunction>
}}}
  * Create your methods and WALLAH!!! You are done and you can call any of the inherited methods from coldbox.system.plugin.cfc


== Overview Diagram ==

Below you can see an overview diagram of how !ColdBox works, you do not need to install special software on your web server or modify your coldfusion installation.

{{{
#!html
<div align="center">
<a href="http://www.luismajano.com/fileshare/blog/ColdboxOverview.jpg" target="_blank" alt="Coldbox Overview"><img src="http://www.luismajano.com/fileshare/blog/ColdboxOverview_tmb.jpg" style="border: 1px outset #eaeaea" ></a>
</div>
}}}

----
'''[[BackLinks(ColdBox)]]'''